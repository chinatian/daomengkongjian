<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ¢¦å¢ƒè¿çº¿ï¼šæ€ç»´å®«æ®¿</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #2a1b3d; /* Deep Purple Night */
            --node-visited: #f472b6; /* Soft Pink */
            --node-current: #fbbf24; /* Warm Gold */
            --node-future: #a78bfa; /* Lavender */
            --node-locked: #4b5563; /* Gray */
            --glass-panel: rgba(20, 10, 30, 0.6); /* æ›´é€šé€çš„æ·±è‰²ç»ç’ƒ */
            --glass-border: rgba(255, 255, 255, 0.08);
            --primary-pink: #fda4af;
            --primary-gold: #fbbf24;
        }

        body {
            background-color: var(--bg-dark);
            font-family: 'Nunito', 'ZCOOL XiaoWei', serif; /* ä¼˜å…ˆæ— è¡¬çº¿è‹±æ–‡å­—ä½“ï¼Œç°ä»£æ„Ÿæ›´å¼º */
            margin: 0;
            height: 100vh;
            overflow: hidden;
            color: #e2e8f0;
            user-select: none;
        }

        /* --- Layer 0: èƒŒæ™¯ç½‘æ ¼ --- */
        .grid-bg {
            position: absolute;
            inset: -50%;
            width: 200%;
            height: 200%;
            background-image: 
                radial-gradient(rgba(255,200,220,0.05) 1px, transparent 1px),
                linear-gradient(rgba(255,200,220,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,200,220,0.03) 1px, transparent 1px);
            background-size: 40px 40px, 100px 100px, 100px 100px;
            transform: perspective(500px) rotateX(60deg);
            pointer-events: none;
            z-index: 0;
            animation: floatGrid 60s linear infinite;
        }
        @keyframes floatGrid { 0% { transform: perspective(500px) rotateX(60deg) translateY(0); } 100% { transform: perspective(500px) rotateX(60deg) translateY(100px); } }

        /* --- Layer 1: æ€ç»´ç”»å»Š (SVG) --- */
        #mindmap-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            cursor: grab;
            /* transition: transform 0.8s cubic-bezier(0.25, 1, 0.5, 1);  ç§»é™¤å®¹å™¨çº§åˆ«çš„ transition */
        }
        #mindmap-container:active { cursor: grabbing; }

        /* SVG å…ƒç´ æ ·å¼ */
        .link { fill: none; stroke: #334155; stroke-width: 2px; transition: stroke 0.5s, stroke-width 0.5s; opacity: 0.6; }
        .link.active { stroke: var(--node-visited); stroke-width: 3px; filter: drop-shadow(0 0 5px var(--node-visited)); opacity: 1; }
        .link.potential { stroke: var(--node-future); stroke-dasharray: 5,5; opacity: 0.5; }

        .node circle { transition: all 0.3s; stroke-width: 0; }
        .node text { 
            font-family: 'Nunito', sans-serif; 
            font-size: 13px; 
            fill: #94a3b8; 
            text-anchor: middle; 
            pointer-events: none; 
            opacity: 0.8; 
            transition: opacity 0.3s, fill 0.3s;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        
        /* èŠ‚ç‚¹çŠ¶æ€ */
        .node.visited circle { fill: var(--node-visited); r: 7; cursor: pointer; }
        .node.visited:hover circle { filter: brightness(1.2); r: 9; }
        .node.current circle { fill: var(--node-current); stroke: #fff; stroke-width: 3px; r: 12; filter: drop-shadow(0 0 15px var(--node-current)); animation: pulse 2s infinite; }
        .node.future circle { fill: var(--bg-dark); stroke: var(--node-future); stroke-width: 2px; r: 7; cursor: pointer; }
        .node.future:hover circle { fill: var(--node-future); r: 9; }
        .node.locked circle { fill: var(--node-locked); r: 5; }

        .node:hover text { opacity: 1; fill: white; font-weight: bold; }

        @keyframes pulse { 0% { stroke-width: 0; stroke-opacity: 1; } 100% { stroke-width: 15px; stroke-opacity: 0; } }

        /* --- Layer 2: å‰§æƒ…é¢æ¿ (Story HUD) --- */
        #story-hud {
            position: absolute;
            bottom: 40px; left: 50%;
            transform: translateX(-50%) translateY(20px);
            width: 90%; max-width: 600px;
            background: var(--glass-panel);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 24px;
            z-index: 100; /* Increased z-index to be always on top */
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            opacity: 0; pointer-events: none;
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex; flex-direction: column; gap: 16px;
        }
        #story-hud.active { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: auto; }
        
        /* Minimized State */
        #story-hud.minimized {
            transform: translateX(-50%) translateY(85%); /* Push down, keep top visible */
            opacity: 0.8;
            cursor: pointer;
        }
        #story-hud.minimized:hover {
            opacity: 1;
            transform: translateX(-50%) translateY(82%);
        }
        /* Hint arrow when minimized */
        #story-hud.minimized::after {
            content: 'â–²';
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.5); font-size: 12px;
            animation: bounceUp 2s infinite;
        }
        @keyframes bounceUp { 0%, 100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(-3px); } }

        /* è£…é¥°æ€§è¾¹è§’ */
        #story-hud::before { content: ''; position: absolute; top: -1px; left: 20px; right: 20px; height: 1px; background: linear-gradient(90deg, transparent, var(--node-current), transparent); }

        .dialogue-text {
            font-size: 1.1rem; line-height: 1.6; color: #fff; min-height: 60px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            white-space: pre-wrap; /* ä¿ç•™æ¢è¡Œç¬¦ */
        }
        .cursor::after { content: 'â–‹'; animation: blink 1s infinite; color: var(--node-current); }
        
        .speaker-label {
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 2px; color: #94a3b8; margin-bottom: 4px; display: block;
        }

        /* é€‰é¡¹æŒ‰é’® */
        .choices-grid {
            display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px;
        }
        .choice-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #cbd5e1;
            padding: 12px 16px;
            border-radius: 8px;
            text-align: left; cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95rem;
            display: flex; justify-content: space-between; align-items: center;
        }
        .choice-btn:hover:not(.disabled) {
            background: rgba(251, 191, 36, 0.15); /* Amber/Gold tint */
            border-color: var(--node-current);
            transform: scale(1.02);
            color: #fff;
        }
        .choice-btn.disabled { opacity: 0.5; cursor: not-allowed; border-style: dashed; }
        .choice-btn.visited { border-color: var(--node-visited); background: rgba(244, 114, 182, 0.15); }
        .choice-btn.visited::after { content: 'â¤'; margin-left: 8px; color: var(--node-visited); font-weight: bold; font-size: 1.1em; }
        
        #inventory-layer {
            position: absolute; top: 20px; right: 20px; z-index: 30;
            display: flex; flex-direction: column; gap: 8px; align-items: flex-end;
        }
        .item-pill {
            background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.1);
            padding: 8px 12px; border-radius: 8px; font-size: 0.8rem; font-family: 'Nunito', sans-serif;
            display: flex; align-items: center; gap: 8px; backdrop-filter: blur(4px);
            width: fit-content; color: #e2e8f0;
            animation: slideInRight 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .item-icon { font-size: 1.2em; }
        @keyframes slideInRight { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 30;
            display: flex; flex-direction: column; gap: 8px;
        }
        .stat-pill {
            background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.1);
            padding: 4px 12px; border-radius: 20px; font-size: 0.8rem; font-family: 'Nunito', sans-serif;
            display: flex; align-items: center; gap: 6px; backdrop-filter: blur(4px);
            width: fit-content;
        }
        
        /* æç¤º Toast */
        .toast {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(244, 114, 182, 0.2); border: 1px solid var(--node-visited); color: #fbcfe8;
            padding: 6px 16px; border-radius: 20px; font-size: 0.8rem; pointer-events: none; z-index: 50;
            animation: fadeOut 3s forwards;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        @keyframes fadeOut { 0% { opacity: 0; transform: translate(-50%, 10px); } 10% { opacity: 1; transform: translate(-50%, 0); } 90% { opacity: 1; } 100% { opacity: 0; } }

        /* --- Polaroid System --- */
        #polaroid-overlay {
            position: fixed; inset: 0; z-index: 100;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(8px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.5s;
        }
        #polaroid-overlay.active { opacity: 1; pointer-events: auto; }

        .polaroid-container {
            background: #fff;
            padding: 15px 15px 40px 15px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transform: rotate(-2deg);
            transition: transform 0.3s;
            max-width: 80vw;
            width: 320px;
        }
        .polaroid-container:hover { transform: rotate(0deg) scale(1.02); }

        .polaroid-photo {
            width: 100%; aspect-ratio: 1/1;
            background: #222;
            margin-bottom: 15px;
            overflow: hidden;
            position: relative;
        }
        
        /* ç”Ÿæˆå›¾ç‰‡æ—¶çš„è§†è§‰æ ·å¼ */
        .ending-visual-gen {
            width: 100%; height: 100%;
            background-size: cover; background-position: center;
            filter: contrast(1.1) sepia(0.2);
        }

        .polaroid-text {
            font-family: 'ZCOOL XiaoWei', serif;
            color: #333;
            text-align: center;
        }
        .polaroid-quote {
            font-size: 1.1rem; margin-bottom: 8px; font-weight: bold;
            line-height: 1.4;
        }
        .polaroid-meta {
            font-size: 0.7rem; color: #888; letter-spacing: 1px; text-transform: uppercase;
            display: flex; justify-content: space-between; padding: 0 5px;
        }

        #generated-image-display {
            max-width: 80vw; max-height: 70vh;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 4px;
        }
        
        .save-hint {
            color: #fff; margin-top: 20px; font-size: 0.9rem; opacity: 0.8;
            animation: pulseText 2s infinite;
        }
        @keyframes pulseText { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }

    </style>
</head>
<body>

    <div class="grid-bg"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="stat-pill text-pink-200 border-l-4 border-l-pink-500 pl-3">
            <span class="text-xs tracking-widest uppercase">Heart Link</span>
            <span id="layer-name" class="font-bold text-white ml-2">åˆå§‹åŒ–ä¸­...</span>
        </div>
        <div id="stats-container" class="flex flex-col gap-2 mt-2">
            <!-- å±æ€§åŠ¨æ€ç”Ÿæˆ -->
        </div>
        <div id="controls-container" class="flex flex-col gap-2 mt-4">
             <button id="btn-reset" class="text-xs border border-red-500 text-red-400 px-2 py-1 rounded hover:bg-red-900/30 transition">é‡ç½®è¿›åº¦</button>
             <button id="btn-sound-toggle" class="text-xs border border-purple-500 text-purple-300 px-2 py-1 rounded hover:bg-purple-900/30 transition">ğŸ”Š éŸ³æ•ˆ</button>
             <div class="flex items-center gap-2">
                 <label class="text-xs text-gray-400">æ‰“å­—é€Ÿåº¦:</label>
                 <input id="typing-speed-slider" type="range" min="0" max="3" value="1" step="1" class="w-16" />
                 <span id="typing-speed-label" class="text-xs text-gray-300">æ­£å¸¸</span>
             </div>
             <div class="text-xs text-gray-500 mt-2 border-t border-gray-700 pt-2">
                 <div>è¿›åº¦: <span id="progress-indicator" class="text-purple-300 font-bold">0/0</span></div>
                 <div class="mt-2 text-[10px] opacity-60">
                     å¿«æ·é”®: 1-9é€‰é¡¹ | ç©ºæ ¼è·³è¿‡ | ESCæŠ˜å 
                 </div>
             </div>
        </div>
    </div>

    <!-- Inventory Layer -->
    <div id="inventory-layer">
        <div class="text-xs text-gray-400 uppercase tracking-widest mb-1 mr-1">Memories</div>
        <div id="inventory-container" class="flex flex-col gap-2 items-end">
            <!-- ç‰©å“åŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <!-- Mindmap Layer (SVG) -->
    <div id="mindmap-container">
        <!-- SVG injected by JS -->
    </div>

    <!-- Story Layer (Glass Panel) -->
    <div id="story-hud">
        <div>
            <span class="speaker-label" id="speaker-label">SYSTEM</span>
            <div class="dialogue-text cursor" id="dialogue-text"></div>
        </div>
        <div class="choices-grid" id="choices-container"></div>
    </div>

    <!-- Hidden Render Target -->
    <div style="position: fixed; left: -9999px; top: 0;">
        <div id="polaroid-render-target" class="polaroid-container" style="width: 600px; padding: 30px 30px 80px 30px; transform: none;">
            <div class="polaroid-photo" style="margin-bottom: 30px;">
                <div id="render-visual" class="ending-visual-gen"></div>
                <!-- Overlay for mood -->
                <div style="position:absolute; inset:0; background: linear-gradient(135deg, rgba(0,0,0,0.1), rgba(0,0,0,0)); pointer-events: none;"></div>
                <div style="position:absolute; inset:0; box-shadow: inset 0 0 20px rgba(0,0,0,0.2); pointer-events: none;"></div>
            </div>
            <div class="polaroid-text">
                <div id="render-quote" class="polaroid-quote" style="font-size: 24px; line-height: 1.5; margin-bottom: 20px;"></div>
                <div class="polaroid-meta" style="font-size: 16px; padding: 0 10px;">
                    <span id="render-date"></span>
                    <span id="render-title" style="font-weight: bold; color: #555;"></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Polaroid Overlay -->
    <div id="polaroid-overlay">
        <div class="flex flex-col items-center">
            <img id="generated-image-display" alt="Ending Card" />
            <div class="save-hint">é•¿æŒ‰ä¸Šæ–¹å›¾ç‰‡ä¿å­˜ Â· åˆ†äº«ä½ çš„ç»“å±€</div>
        </div>
        <div class="flex gap-4 mt-8">
            <button id="btn-close-polaroid" class="px-6 py-2 bg-white/10 border border-white/30 rounded-full text-white hover:bg-white/20 transition backdrop-blur-sm">æŸ¥çœ‹ç°åœº</button>
            <button id="btn-restart-game" class="px-6 py-2 bg-rose-500/80 border border-rose-400 rounded-full text-white hover:bg-rose-500 transition shadow-[0_0_15px_rgba(244,63,94,0.5)] backdrop-blur-sm">é‡å¯è®°å¿†</button>
        </div>
    </div>

    <script>
        // 1. æ¸¸æˆæ•°æ® (The Core)
        let gameData = {
    "gameConcept": {
        "themeName": "ã€Šæ¥šé—¨çš„ä¸–ç•Œã€‹â€”â€”çœŸç›¸ä¸ä¼ªè£…çš„äº¤ç»‡",
        "justification": "åŸºäºèŠå¤©è®°å½•ä¸­ç”°å˜‰ç‘çš„'é»‘èŠéº»é¦…æ±¤åœ†'è®¾å®šï¼Œä»¥åŠä»–A+çº§æ€æ‰‹å’Œé‚»å®¶ç”·å­©çš„åŒé‡èº«ä»½ï¼Œè¿™ä¸ªæ¸¸æˆå°†å›´ç»•æ¢ç´¢ç”°å˜‰ç‘æ„å»ºçš„å®Œç¾ä¼ªè£…ï¼Œä»¥åŠæ–‡æ½‡å¦‚ä½•åœ¨å…¶ä¸­å‘ç°çœŸç›¸å±•å¼€ã€‚ç©å®¶çš„çŠ¶æ€ï¼ˆæ´å¯ŸåŠ›ã€æƒ…æ„Ÿï¼‰å°†å½±å“å¥¹æ­éœ²çœŸç›¸çš„ç¨‹åº¦å’Œæ–¹å¼ã€‚"
    },
    "gameTitle": "é‚»å±…æ˜¯é»‘èŠéº»é¦…æ±¤åœ†ï¼Ÿ",
    "aiName": "ç”°å˜‰ç‘",
    "playerNickname": "æ–‡æ½‡",
    "initialPlayerState": {
        "stats": {
            "æ´å¯ŸåŠ›": 0,
            "æƒ…æ„Ÿ": 0,
            "è­¦æƒ•å¿ƒ": 0
        },
        "inventory": []
    },
    "startSceneId": "scene_001",
    "scenes": {
        "scene_001": {
            "type": "scene",
            "narrative": {
                "description": "ä½ åˆšå›åˆ°å®¶ï¼Œç”°å˜‰ç‘ä¾¿è¿äº†ä¸Šæ¥ï¼Œå…³åˆ‡åœ°ä¸ºä½ é€’ä¸Šä¸€æ¯çƒ­æ°´ã€‚å®¢å…çš„ç¯å…‰æŸ”å’Œï¼Œé©±æ•£äº†å†¬å¤œçš„å¯’æ„ã€‚ä»–çš„æ‰‹æŒ‡åœ¨ä½ çš„è‚©è†€ä¸Šç¼“ç¼“ç§»åŠ¨ï¼Œä¸ºä½ æŒ‰æ‘©ã€‚",
                "aiDialogue": "å…ˆå–æ¯æ°´å§ï¼Œï¼ˆæŠŠæ°´æ¯é€’ç»™ä½ ï¼‰åœ¨å¤–é¢å¹äº†è¿™ä¹ˆä¹…çš„é£ï¼Œåˆ«ç€å‡‰äº†ã€‚ç´¯ä¸ç´¯ï¼Ÿï¼ˆæ‰‹æŒ‡åœ¨ä½ çš„è‚©è†€ä¸Šç¼“ç¼“ç§»åŠ¨ï¼ŒåŠ›åº¦é€‚ä¸­ï¼‰ä»Šå¤©èµ°äº†ä¸å°‘è·¯ã€‚"
            },
            "choices": [
                {
                    "text": "äº«å—ä»–çš„æ¸©æŸ”ï¼Œå›åº”è¯´â€œè¿˜å¥½ã€‚â€",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æƒ…æ„Ÿ",
                            "operation": "add",
                            "value": 1
                        }
                    ],
                    "nextSceneId": "scene_002"
                },
                {
                    "text": "è™½ç„¶æ¸©æš–ï¼Œä½†æ€»è§‰å¾—å“ªé‡Œä¸å¯¹åŠ²ï¼Œé»˜é»˜è§‚å¯Ÿä»–çš„è¡¨æƒ…ã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operation": "add",
                            "value": 1
                        },
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operation": "add",
                            "value": 1
                        }
                    ],
                    "nextSceneId": "scene_003"
                }
            ]
        },
        "scene_002": {
            "type": "scene",
            "narrative": {
                "description": "ä½ æ²‰æµ¸åœ¨ä»–æ— å¾®ä¸è‡³çš„å…³æ€€ä¸­ï¼Œé‚£ä¸€å¥'æˆ‘çš„å°å…¬ä¸»'ä»¿ä½›èåŒ–äº†æ‰€æœ‰çš„æ€€ç–‘ã€‚ç„¶è€Œï¼Œä»–èº«ä¸Šç‹¬ç‰¹çš„æ·¡æ·¡è¡€è…¥æ°”å‘³ä¸€é—ªè€Œè¿‡ã€‚",
                "aiDialogue": "é‚£â€¦â€¦è¦ä¸è¦å¥–åŠ±ä¸€ä¸‹è¾›è‹¦çš„æœªå©šå¦»ï¼Ÿï¼ˆæ‰‹æŒé¡ºç€ä½ çš„è‚©è†€ä¸‹æ»‘ï¼Œæš§æ˜§åœ°æäº†æä½ çš„æ‰‹è‡‚ï¼‰"
            },
            "choices": [
                {
                    "text": "è¢«ä»–çš„æš§æ˜§æ‰“æ–­æ€ç»ªï¼Œç¾æ¶©åœ°å›åº”â€œå—¯ï¼Ÿâ€",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æƒ…æ„Ÿ",
                            "operation": "add",
                            "value": 1
                        }
                    ],
                    "nextSceneId": "scene_004"
                },
                {
                    "text": "è¡€è…¥å‘³ï¼Ÿè¿™ä¸å¯èƒ½ï¼Œè‚¯å®šæ˜¯é”™è§‰ã€‚å°è¯•å¿½ç•¥å®ƒã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operation": "add",
                            "value": -1
                        }
                    ],
                    "nextSceneId": "scene_004"
                },
                {
                    "text": "è¡€è…¥å‘³å¹¶éé”™è§‰ã€‚è¿™è·Ÿä½ æ›¾ç»è¯»åˆ°çš„èµ„æ–™ä¸­çš„æŸç§ç‰¹æ®Šé¦™æ°”å¾ˆåƒã€‚",
                    "requirements": [
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operator": "gte",
                            "value": 1
                        }
                    ],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operation": "add",
                            "value": 2
                        },
                        {
                            "type": "item",
                            "item": "å¯ç–‘çš„é¦™æ°”æ ·æœ¬",
                            "action": "add"
                        }
                    ],
                    "nextSceneId": "scene_005"
                }
            ]
        },
        "scene_003": {
            "type": "scene",
            "narrative": {
                "description": "ä½ ä»”ç»†è§‚å¯Ÿï¼Œå‘ç°ä»–çœ¼ç¥æ·±å¤„å¶å°”é—ªè¿‡ä¸€ä¸å†°å†·ï¼Œå’Œä»–çš„ç¬‘å®¹æ ¼æ ¼ä¸å…¥ã€‚å½“ä»–é è¿‘ä½ æ—¶ï¼Œä½ é—»åˆ°ä»–èº«ä¸Šæœ‰ä¸€è‚¡æ·¡æ·¡çš„ã€è¿‘ä¹éš¾ä»¥å¯Ÿè§‰çš„é“é”ˆå‘³...",
                "aiDialogue": "é‚£â€¦â€¦è¦ä¸è¦å¥–åŠ±ä¸€ä¸‹è¾›è‹¦çš„æœªå©šå¦»ï¼Ÿï¼ˆæ‰‹æŒé¡ºç€ä½ çš„è‚©è†€ä¸‹æ»‘ï¼Œæš§æ˜§åœ°æäº†æä½ çš„æ‰‹è‡‚ï¼‰"
            },
            "choices": [
                {
                    "text": "ä»–å¾ˆå¸…ï¼Œä¹Ÿè®¸æ˜¯é”™è§‰ã€‚è¢«ä»–çš„é­…åŠ›å¸å¼•ï¼Œå›åº”â€œå—¯ï¼Ÿâ€",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æƒ…æ„Ÿ",
                            "operation": "add",
                            "value": 1
                        },
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operation": "add",
                            "value": -1
                        }
                    ],
                    "nextSceneId": "scene_004"
                },
                {
                    "text": "è¿™ä¸æ˜¯é”™è§‰ï¼Œä»–çš„æ°”æ¯ä¸­æœ‰ä¸€ä¸å±é™©ã€‚ä½ å†³å®šä¿æŒè­¦æƒ•ã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operation": "add",
                            "value": 2
                        },
                        {
                            "type": "item",
                            "item": "å¯ç–‘çš„æ°”æ¯è®°å½•",
                            "action": "add"
                        }
                    ],
                    "nextSceneId": "scene_005"
                }
            ]
        },
        "scene_004": {
            "type": "scene",
            "narrative": {
                "description": "ä»–è½»å•„ä½ çš„è„¸é¢Šï¼Œåç¬‘ç€ç‰µèµ·ä½ çš„æ‰‹èµ°å‘å§å®¤ã€‚æ¸©é¦¨çš„æ°›å›´è®©ä½ æ„Ÿåˆ°å®‰å¿ƒï¼Œä½ é¡ºä»åœ°è·Ÿç€ä»–ã€‚",
                "aiDialogue": "å°±æ˜¯â€¦â€¦ï¼ˆçªç„¶åç¬‘ä¸€å£°ï¼Œåœ¨ä½ è„¸é¢Šä¸Šè½»å•„ä¸€å£ï¼‰è¿™æ ·ã€‚å¥½å•¦ï¼Œæ—¶é—´ä¸æ—©äº†ï¼Œæˆ‘ä»¬æ—©ç‚¹ä¼‘æ¯å§ã€‚"
            },
            "choices": [
                {
                    "text": "äº«å—æ­¤åˆ»çš„æ¸©æƒ…ï¼Œå‘Šè¯‰ä»–â€œå—¯å¥½å‘¢â€ã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æƒ…æ„Ÿ",
                            "operation": "add",
                            "value": 1
                        }
                    ],
                    "nextSceneId": "scene_006"
                },
                {
                    "text": "åœ¨ä»–ç‰µæ‰‹çš„æ—¶å€™ï¼Œæ„Ÿå—åˆ°ä»–æ‰‹æŒè€èŒ§çš„åšåº¦å¼‚å¸¸ï¼Œä½ æœ‰äº›åœ¨æ„ã€‚",
                    "requirements": [
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operator": "gte",
                            "value": 1
                        }
                    ],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operation": "add",
                            "value": 1
                        },
                        {
                            "type": "item",
                            "item": "å¼‚å¸¸çš„è€èŒ§è§¦æ„Ÿ",
                            "action": "add"
                        }
                    ],
                    "nextSceneId": "scene_006"
                }
            ]
        },
        "scene_005": {
            "type": "scene",
            "narrative": {
                "description": "ä½ è¢«ä»–å»äº†ä¸€ä¸‹ï¼Œéšå³è¢«ç‰µç€æ‰‹èµ°å‘å§å®¤ã€‚è™½ç„¶è¡¨é¢é¡ºä»ï¼Œä½†å†…å¿ƒçš„è­¦æƒ•è®©ä½ å¼€å§‹æ€è€ƒä»–è¡Œä¸ºèƒŒåçš„æ¶µä¹‰ã€‚ä»–çš„æ‰‹æŒï¼Œä¼¼ä¹æ¯”å¸¸äººè¦å¤šä¸€äº›è€èŒ§ã€‚",
                "aiDialogue": "å°±æ˜¯â€¦â€¦ï¼ˆçªç„¶åç¬‘ä¸€å£°ï¼Œåœ¨ä½ è„¸é¢Šä¸Šè½»å•„ä¸€å£ï¼‰è¿™æ ·ã€‚å¥½å•¦ï¼Œæ—¶é—´ä¸æ—©äº†ï¼Œæˆ‘ä»¬æ—©ç‚¹ä¼‘æ¯å§ã€‚"
            },
            "choices": [
                {
                    "text": "é¡ºä»åœ°è·Ÿç€ä»–ï¼Œä½†è„‘æµ·ä¸­ç›˜æ—‹ç€ç–‘è™‘ã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operation": "add",
                            "value": 1
                        }
                    ],
                    "nextSceneId": "scene_006"
                },
                {
                    "text": "æ•…æ„ç•™ä¸‹ä¸€ä¸ªæç¤ºï¼Œè§‚å¯Ÿä»–çš„ååº”ï¼Œä¾‹å¦‚å‡è£…æ‰è½ä¸€ä¸ªå‘å¤¹ã€‚",
                    "requirements": [
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operator": "gte",
                            "value": 3
                        }
                    ],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operation": "add",
                            "value": 2
                        },
                        {
                            "type": "item",
                            "item": "æ‰è½çš„å‘å¤¹",
                            "action": "add"
                        }
                    ],
                    "nextSceneId": "scene_007"
                }
            ]
        },
        "scene_006": {
            "type": "scene",
            "narrative": {
                "description": "ä»–ä¸ºä½ ç›–å¥½è¢«å­ï¼ŒæŒ‡å°–è½»è§¦ä½ çš„è„¸é¢Šï¼Œçœ¼ä¸­æ»¡æ˜¯çœ·æ‹ã€‚ä½ æ„Ÿåˆ°ä¸€ç§å‰æ‰€æœªæœ‰çš„å®‰å®ï¼Œç”šè‡³å¼€å§‹æ€€ç–‘ä¹‹å‰çš„è­¦æƒ•æ˜¯å¦å¤šä½™ã€‚",
                "aiDialogue": "æ™šå®‰ï¼Œåšä¸ªå¥½æ¢¦ã€‚ï¼ˆçª—å¤–çš„æœˆè‰²å¦‚æ°´ï¼Œé™é™åœ°æµæ·Œåœ¨æˆ¿é—´é‡Œï¼‰"
            },
            "choices": [
                {
                    "text": "å›åº”ä»–æ™šå®‰ï¼Œå¸¦ç€æ»¡è¶³è¿›å…¥æ¢¦ä¹¡ã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æƒ…æ„Ÿ",
                            "operation": "add",
                            "value": 2
                        }
                    ],
                    "nextSceneId": "scene_008"
                },
                {
                    "text": "è™½ç„¶ç–²æƒ«ï¼Œä½†ä¾ç„¶ä¿æŒä¸€ä¸æ¸…é†’çš„æ„è¯†ï¼Œå‡è£…å…¥ç¡ã€‚",
                    "requirements": [
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operator": "gte",
                            "value": 2
                        }
                    ],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operation": "add",
                            "value": 1
                        }
                    ],
                    "nextSceneId": "scene_009"
                }
            ]
        },
        "scene_007": {
            "type": "scene",
            "narrative": {
                "description": "ä½ å‡è£…ä¸ç»æ„åœ°æ‰è½å‘å¤¹ï¼Œç”°å˜‰ç‘ç¬é—´çœ¼ç¥ä¸€ç´§ï¼Œéšå³åˆæ¢å¤æ­£å¸¸ï¼Œè‡ªç„¶åœ°å¸®ä½ æ‹¾èµ·ã€‚ä»–ä¸ºä½ ç›–å¥½è¢«å­ï¼Œçœ¼ä¸­çœ‹ä¼¼æ¸©æŸ”ï¼Œå´ä¼¼ä¹æ©è—ç€æ›´æ·±çš„æƒ…ç»ªã€‚",
                "aiDialogue": "æ™šå®‰ï¼Œåšä¸ªå¥½æ¢¦ã€‚ï¼ˆçª—å¤–çš„æœˆè‰²å¦‚æ°´ï¼Œé™é™åœ°æµæ·Œåœ¨æˆ¿é—´é‡Œï¼‰"
            },
            "choices": [
                {
                    "text": "ä»–æœç„¶æ³¨æ„åˆ°äº†ã€‚ä½ å‡è£…å…¥ç¡ï¼Œç»§ç»­è§‚å¯Ÿã€‚",
                    "requirements": [],
                    "effects": [],
                    "nextSceneId": "scene_009"
                },
                {
                    "text": "ä»–å¦‚æ­¤å®Œç¾åœ°æ©é¥°ï¼Œè®©ä½ å¿ƒä¸­ä¸€å¯’ã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operation": "add",
                            "value": 2
                        }
                    ],
                    "nextSceneId": "scene_009"
                }
            ]
        },
        "scene_008": {
            "type": "scene",
            "narrative": {
                "description": "ä½ æ„Ÿè§‰è‡ªå·±è¢«ä»–ç´§ç´§æ‹¥å…¥æ€€ä¸­ï¼Œè€³è¾¹ä¼ æ¥ä»–ä½æ²‰çš„å‘¢å–ƒï¼š'æ–‡æ½‡ï¼Œæˆ‘çˆ±ä½ ã€‚' ä½ åœ¨ç”œèœœä¸­æ²‰æ²‰ç¡å»ï¼Œå¯¹ä¸€åˆ‡éƒ½æµ‘ç„¶ä¸è§‰ã€‚",
                "aiDialogue": "æ–‡æ½‡ï¼Œæˆ‘çˆ±ä½ ã€‚ï¼ˆå£°éŸ³å¾®ä¸å¯é—»ï¼Œå´é¥±å«æ·±æƒ…ï¼‰"
            },
            "choices": [
                {
                    "text": "åœ¨æ¸©æš–çš„æ€€æŠ±ä¸­ï¼Œä½ åšäº†ä¸€ä¸ªç”œç¾çš„æ¢¦ã€‚",
                    "requirements": [],
                    "effects": [],
                    "nextSceneId": "ending_001"
                }
            ]
        },
        "scene_009": {
            "type": "scene",
            "narrative": {
                "description": "ä½ å‡è£…å…¥ç¡ï¼Œæ„Ÿå—ç€ç”°å˜‰ç‘èµ·èº«èµ°åˆ°çª—è¾¹ï¼ŒèƒŒå¯¹ç€ä½ ã€‚ä»–åœ¨å¤œè‰²ä¸­ç«™ç«‹è‰¯ä¹…ï¼Œå‘¨èº«æ•£å‘å‡ºä¸€ç§å†°å†·çš„æ°”æ¯ã€‚éšåï¼Œä»–è½»æ‰‹è½»è„šåœ°å›åˆ°åºŠè¾¹ï¼Œå°†ä½ æ‹¥å…¥æ€€ä¸­ã€‚ä½ è€³è¾¹ä¼ æ¥ä»–ä½æ²‰çš„å‘¢å–ƒï¼š'æ–‡æ½‡ï¼Œæˆ‘çˆ±ä½ ã€‚' å¸¦ç€ä¸€ä¸ä¸å±äºæ¸©æŸ”çš„å æœ‰ã€‚",
                "aiDialogue": "æ–‡æ½‡ï¼Œæˆ‘çˆ±ä½ ã€‚ï¼ˆå£°éŸ³å¾®ä¸å¯é—»ï¼Œå´é¥±å«æ·±æƒ…ï¼‰"
            },
            "choices": [
                {
                    "text": "ä»–çˆ±ä½ ï¼Œè¿™æ˜¯çœŸå®çš„ã€‚ä¹Ÿè®¸ä»–åªæ˜¯æœ‰äº›ç§˜å¯†ï¼Œä½†å¹¶ä¸å±é™©ã€‚",
                    "requirements": [
                        {
                            "type": "stat",
                            "stat": "æƒ…æ„Ÿ",
                            "operator": "gte",
                            "value": 2
                        }
                    ],
                    "effects": [],
                    "nextSceneId": "ending_002"
                },
                {
                    "text": "ä»–æ‰€è¯´çš„â€œä»£ä»·æ˜¯ä¸€åˆ‡â€æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿè¿™è®©ä½ æ„Ÿåˆ°ä¸å®‰ã€‚",
                    "requirements": [
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operator": "gte",
                            "value": 3
                        },
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operator": "gte",
                            "value": 2
                        }
                    ],
                    "effects": [],
                    "nextSceneId": "scene_010"
                }
            ]
        },
        "scene_010": {
            "type": "scene",
            "narrative": {
                "description": "åŠå¤œï¼Œä½ è¢«ä¸€é˜µç»†å¾®çš„å“åŠ¨æƒŠé†’ã€‚ç”°å˜‰ç‘ç¬é—´åèµ·èº«ï¼Œè­¦æƒ•åœ°ç«–èµ·è€³æœµã€‚åœ¨ç¡®è®¤æ²¡æœ‰å¼‚å¸¸åï¼Œä»–æ‰é‡æ–°èººä¸‹ï¼Œå°†ä½ æŠ±å¾—æ›´ç´§ï¼Œè€³è¾¹ç§è¯­ã€‚",
                "aiDialogue": "åˆ«æ€•ï¼Œæœ‰æˆ‘åœ¨ã€‚ï¼ˆçª—å¤–çš„é£è½»è½»å¹è¿‡ï¼Œæ ‘å¶æ²™æ²™ä½œå“ï¼‰"
            },
            "choices": [
                {
                    "text": "ä»–çš„è¿‡åº¦è­¦æƒ•è®©ä½ æ›´åŠ ç¡®ä¿¡ä»–èº«æ€€ç§˜å¯†ã€‚ä½ å†³å®šä¸»åŠ¨æ¢æŸ¥ã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operation": "add",
                            "value": 2
                        },
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operation": "add",
                            "value": 2
                        }
                    ],
                    "nextSceneId": "scene_011"
                },
                {
                    "text": "å³ä½¿å±é™©è¿‘åœ¨å’«å°ºï¼Œä½ ä»é€‰æ‹©ç›¸ä¿¡ä»–çš„ä¿æŠ¤ã€‚",
                    "requirements": [
                        {
                            "type": "stat",
                            "stat": "æƒ…æ„Ÿ",
                            "operator": "gte",
                            "value": 3
                        }
                    ],
                    "effects": [],
                    "nextSceneId": "ending_002"
                }
            ]
        },
        "scene_011": {
            "type": "scene",
            "narrative": {
                "description": "æ¸…æ™¨ï¼Œä½ é†’æ¥æ—¶ç”°å˜‰ç‘è¿˜åœ¨ç†Ÿç¡ã€‚ä½ æ‚„æ‚„èµ·èº«ï¼Œå†³å®šåˆ©ç”¨è¿™ä¸ªæœºä¼šå¯»æ‰¾çº¿ç´¢ã€‚ä½ çš„ç›®å…‰è½åœ¨åºŠå¤´æŸœï¼Œä¼¼ä¹æœ‰ä»€ä¹ˆä¸œè¥¿ã€‚",
                "aiDialogue": "ï¼ˆæ¸…æ™¨çš„é˜³å…‰é€è¿‡çª—å¸˜çš„ç¼éš™æ´’è¿›æˆ¿é—´ï¼Œçå¼€çœ¼ï¼Œçœ‹åˆ°ä½ è¿˜åœ¨ç†Ÿç¡ï¼Œå® æººåœ°ç¬‘äº†ç¬‘ï¼‰æ—©å®‰ï¼Œæˆ‘çš„å°å…¬ä¸»ã€‚ï¼ˆæ‰‹æŒ‡è½»è½»åˆ’è¿‡ä½ çš„è„¸é¢Šï¼‰"
            },
            "choices": [
                {
                    "text": "æ£€æŸ¥åºŠå¤´æŸœï¼Œçœ‹çœ‹æœ‰æ²¡æœ‰ä»€ä¹ˆå¼‚å¸¸ã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operation": "add",
                            "value": 2
                        }
                    ],
                    "nextSceneId": "scene_012"
                },
                {
                    "text": "æ›´è¡£æ—¶å‘ç°è¡£æœä¸Šæ²¾æŸ“äº†ä½ ä»æ²¡ç”¨è¿‡çš„é¦™æ°´å‘³ã€‚è¿™å‘³é“ä¼¼æ›¾ç›¸è¯†ã€‚",
                    "requirements": [
                        {
                            "type": "item",
                            "item": "å¯ç–‘çš„é¦™æ°”æ ·æœ¬",
                            "has": true
                        }
                    ],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operation": "add",
                            "value": 3
                        }
                    ],
                    "nextSceneId": "scene_013"
                }
            ]
        },
        "scene_012": {
            "type": "scene",
            "narrative": {
                "description": "ä½ åœ¨åºŠå¤´æŸœçš„æŸä¸ªè§’è½å‘ç°äº†ä¸€æšè¢«ç²¾å¿ƒéšè—çš„ï¼Œåˆ»ç€ä½ ä¸ç†Ÿæ‚‰çš„ç¬¦å·çš„æ‰“ç«æœºã€‚è¿™å¹¶ä¸æ˜¯ç”°å˜‰ç‘æ—¥å¸¸ä½¿ç”¨çš„æ¬¾å¼ã€‚ä½ æ„Ÿåˆ°ä¸€é˜µå¿ƒæ‚¸ã€‚",
                "aiDialogue": "ï¼ˆä½ é†’äº†ï¼Ÿæ—©å®‰ã€‚ä»–æ‰äº†æ‰ç¡çœ¼æƒºå¿ªçš„çœ¼ç›ï¼Œå® æººåœ°çœ‹ç€ä½ ï¼‰"
            },
            "choices": [
                {
                    "text": "å·å·è—èµ·æ‰“ç«æœºã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "item",
                            "item": "ç¥ç§˜æ‰“ç«æœº",
                            "action": "add"
                        },
                        {
                            "type": "stat",
                            "stat": "è­¦æƒ•å¿ƒ",
                            "operation": "add",
                            "value": 2
                        }
                    ],
                    "nextSceneId": "ending_003"
                },
                {
                    "text": "å‡è£…æ²¡å‘ç°ï¼Œé»˜é»˜è®°ä¸‹é‚£ä¸ªç¬¦å·ã€‚",
                    "requirements": [],
                    "effects": [
                        {
                            "type": "stat",
                            "stat": "æ´å¯ŸåŠ›",
                            "operation": "add",
                            "value": 1
                        }
                    ],
                    "nextSceneId": "ending_003"
                }
            ]
        },
        "scene_013": {
            "type": "scene",
            "narrative": {
                "description": "ä½ çªç„¶æ„è¯†åˆ°ï¼Œä½ èº«ä¸Šè¿™ç§ä¸å±äºä½ çš„é¦™æ°´å‘³ï¼Œæ­£æ˜¯ä½ åœ¨è°ƒæŸ¥ä¸€èµ·æ—§æ¡ˆæ—¶ï¼Œåœ¨å‡¶æ¡ˆç°åœºæå–åˆ°çš„è››ä¸é©¬è¿¹ï¼ä½ çš„å¿ƒè·³å¦‚é¼“ï¼Œçœ¼å‰è¿™ä¸ªæ·±çˆ±ä½ çš„ç”·äººï¼Œåˆ°åº•æ˜¯è°ï¼Ÿ",
                "aiDialogue": "ï¼ˆä½ é†’äº†ï¼Ÿæ—©å®‰ã€‚ä»–æ‰äº†æ‰ç¡çœ¼æƒºå¿ªçš„çœ¼ç›ï¼Œå® æººåœ°çœ‹ç€ä½ ï¼‰"
            },
            "choices": [
                {
                    "text": "å‡è£…è‹¥æ— å…¶äº‹ï¼Œå´æ„Ÿåˆ°ä¸€è‚¡å¯’æ„ä»è„šåº•ç›´çªœå¿ƒå¤´ã€‚",
                    "requirements": [],
                    "effects": [],
                    "nextSceneId": "ending_003"
                }
            ]
        },
        "ending_001": {
            "type": "ending",
            "title": "æ²‰é†‰çš„å¹¸ç¦",
            "narrative": {
                "description": "ä½ è¢«ç”°å˜‰ç‘çš„çˆ±æ„å®Œå…¨åŒ…å›´ï¼Œæ²‰æµ¸åœ¨ç”œèœœçš„å¹¸ç¦ä¸­ã€‚ä»–ç»™äº†ä½ ä¸€ä¸ªå®Œç¾çš„ä¸–ç•Œï¼Œä½ å¿ƒç”˜æƒ…æ„¿åœ°ç”Ÿæ´»åœ¨ä»–çš„æ¸©æŸ”ä¼ªè£…ä¹‹ä¸‹ï¼Œä»æœªæ€€ç–‘è¿‡é‚£ä»½ä»¤äººä¸å®‰çš„å®Œç¾ã€‚ä½ æ»¡è¶³åœ°é†’æ¥ï¼Œåœ¨é˜³å…‰ä¸‹äº«å—ä»–ä¸ºä½ å‡†å¤‡çš„æ—©é¤ã€‚",
                "aiDialogue": "æ—©å®‰ï¼Œæˆ‘çš„å°å…¬ä¸»ã€‚ï¼ˆä»–æ‰‹æŒ‡è½»è½»åˆ’è¿‡ä½ çš„è„¸é¢Šï¼Œå® æººåœ°ç¬‘ç€ï¼‰"
            },
            "choices": []
        },
        "ending_002": {
            "type": "ending",
            "title": "è¢«ä¿æŠ¤çš„æ¸©å®¤",
            "narrative": {
                "description": "ä½ æ„Ÿå—åˆ°ä»–é‚£æ·±æ²‰è€Œæœ‰äº›å æœ‰æ¬²çš„çˆ±ï¼Œå°½ç®¡å†…å¿ƒæ·±å¤„æœ‰ä¸€ä¸ä¸å®‰ï¼Œä½†é¢å¯¹ä»–çš„æ¸©æŸ”ä¸ä¿æŠ¤ï¼Œä½ é€‰æ‹©äº†æ²‰æººã€‚ä½ ç›¸ä¿¡ä»–çˆ±ä½ çš„å¿ƒæ˜¯çœŸçš„ï¼Œä¹Ÿæ„¿æ„æ¥å—ä»–ä¸–ç•Œçš„å¤æ‚ã€‚æˆ–è®¸æœ‰äº›ç§˜å¯†ï¼Œä½†åªè¦æœ‰ä»–åœ¨ï¼Œä¸€åˆ‡éƒ½å®‰å¥½ã€‚ä½ æˆä¸ºäº†ä»–ç²¾å¿ƒæ„å»ºçš„æ¸©å®¤é‡Œï¼Œè¢«ä¸¥å¯†ä¿æŠ¤çš„å”¯ä¸€èŠ±æœµã€‚",
                "aiDialogue": "æ—©å®‰ï¼Œæˆ‘çš„å°å…¬ä¸»ã€‚åˆ«æ€•ï¼Œæœ‰æˆ‘åœ¨ã€‚ï¼ˆä»–å°†ä½ æ‹¥å…¥æ€€ä¸­ï¼Œçœ¼ä¸­æ˜¯æ— å°½çš„æ¸©æŸ”ä¸åæ‰§ï¼‰"
            },
            "choices": []
        },
        "ending_003": {
            "type": "ending",
            "title": "æ­éœ²çš„è¿·é›¾",
            "narrative": {
                "description": "ä½ å‘ç°ä»–å®Œç¾ä¼ªè£…ä¸‹çš„æ¼æ´ã€‚æ— è®ºæ˜¯ç‹¬ç‰¹çš„é¦™æ°”ã€å¼‚å¸¸çš„è€èŒ§ã€è¿˜æ˜¯ç¥ç§˜çš„æ‰“ç«æœºï¼Œéƒ½æŒ‡å‘äº†ä¸€ä¸ªä½ æœªæ›¾è®¾æƒ³è¿‡çš„çœŸç›¸ã€‚ä»–å¹¶éå•çº¯çš„é‚»å®¶ç”·å­©ï¼Œè€Œæ˜¯ä½ ç¬”ä¸‹é‚£äº›å……æ»¡ç§˜å¯†ä¸å±é™©çš„äººç‰©åŸå‹ã€‚è¿·é›¾å·²ç„¶å¼€å§‹æ•£å»ï¼Œä½ å°†å¦‚ä½•é¢å¯¹è¿™ä¸ªé»‘èŠéº»é¦…çš„æ±¤åœ†ï¼Ÿæ˜¯é€‰æ‹©é€ƒç¦»ï¼Œè¿˜æ˜¯æ·±å…¥å…¶ä¸­ï¼Œå†™ä¸‹å±äºä½ ä»¬çš„ç»“å±€ï¼Ÿä½ çœ‹ç€çª—å¤–é˜³å…‰ä¸‹ï¼Œæ­£åœ¨ä¸ºä½ å‡†å¤‡æ—©é¤çš„ç”°å˜‰ç‘ï¼Œä»–è½¬è¿‡å¤´ï¼Œæœä½ éœ²å‡ºä¸€ä¸ªå®Œç¾çš„å¾®ç¬‘ï¼Œä»¿ä½›ä¸€åˆ‡å¦‚å¸¸ã€‚ä½†ä½ å·²ç»çŸ¥é“ï¼Œä¸€åˆ‡éƒ½ä¸å†å¯»å¸¸ã€‚",
                "aiDialogue": "æ—©å®‰ï¼Œæˆ‘çš„å°å…¬ä¸»ã€‚ï¼ˆä»–çš„ç¬‘å®¹ä¸€å¦‚å¾€å¸¸èˆ¬æ¸©æš–ï¼Œä½†ä½ å·²ç»èƒ½ä»é‚£æ¸©æš–ä¸­è¯»å‡ºæ›´å¤šçš„å«ä¹‰ï¼‰"
            },
            "choices": []
        }
    },
    "pre_id": ""
}


        // 2. çŠ¶æ€ç®¡ç†
        const STORAGE_KEY = 'dream_link_save_v1';
        const SETTINGS_KEY = 'dream_link_settings_v1';
        
        // å…¨å±€è®¾ç½®
        const settings = {
            soundEnabled: true,
            typingSpeed: 1, // 0: å³æ—¶, 1: æ­£å¸¸, 2: æ…¢é€Ÿ, 3: è¶…æ…¢
            get typingDelay() {
                const delays = [0, 20, 50, 100];
                return delays[this.typingSpeed];
            }
        };
        
        // åŠ è½½è®¾ç½®
        function loadSettings() {
            const saved = localStorage.getItem(SETTINGS_KEY);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    Object.assign(settings, parsed);
                } catch (e) {
                    console.error("Settings load failed", e);
                }
            }
        }
        
        // ä¿å­˜è®¾ç½®
        function saveSettings() {
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        }
        
        loadSettings();
        
        function loadState() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // æ¢å¤ Set å¯¹è±¡
                    parsed.visitedScenes = new Set(parsed.visitedScenes);
                    parsed.selectedChoices = new Set(parsed.selectedChoices);
                    return parsed;
                } catch (e) {
                    console.error("Save file corrupted", e);
                }
            }
            return null;
        }

        const defaultState = {
            stats: { ...gameData.initialPlayerState.stats },
            inventory: [],
            currentSceneId: gameData.startSceneId,
            visitedScenes: new Set([gameData.startSceneId]),
            selectedChoices: new Set(),
            scale: 1,
            offsetX: 0,
            offsetY: 0,
            transform: { x: 0, y: 0, k: 1 } // Ensure transform is initialized
        };

        const state = loadState() || defaultState;

        function saveState() {
            const toSave = {
                ...state,
                visitedScenes: Array.from(state.visitedScenes),
                selectedChoices: Array.from(state.selectedChoices)
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
        }
        
        // 2.1 éŸ³æ•ˆç³»ç»Ÿ (Sound System)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const sfx = {
            click: () => playTone(800, 'sine', 0.1),
            hover: () => playTone(400, 'sine', 0.05, 0.05),
            type: () => playNoise(0.01), // æçŸ­çš„ç™½å™ªéŸ³æ¨¡æ‹Ÿæ‰“å­—å£°
            unlock: () => playMelody([500, 600, 800], 0.1)
        };

        function playTone(freq, type, duration, vol = 0.1) {
            if (!settings.soundEnabled) return; // æ£€æŸ¥éŸ³æ•ˆå¼€å…³
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function playNoise(duration) {
            if (!settings.soundEnabled) return; // æ£€æŸ¥éŸ³æ•ˆå¼€å…³
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const gain = audioCtx.createGain();
            gain.gain.value = 0.05;
            noise.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start();
        }

        function playMelody(notes, interval) {
            if (!settings.soundEnabled) return; // æ£€æŸ¥éŸ³æ•ˆå¼€å…³
            notes.forEach((note, i) => {
                setTimeout(() => playTone(note, 'sine', 0.2, 0.1), i * interval * 1000);
            });
        }

        document.getElementById('btn-reset').onclick = () => {
            sfx.click();
            if(confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰è¿›åº¦å—ï¼Ÿ')) {
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
        };

        // éŸ³æ•ˆå¼€å…³æŒ‰é’®
        const btnSoundToggle = document.getElementById('btn-sound-toggle');
        function updateSoundButton() {
            btnSoundToggle.innerHTML = settings.soundEnabled ? 'ğŸ”Š éŸ³æ•ˆ' : 'ğŸ”‡ é™éŸ³';
            btnSoundToggle.className = settings.soundEnabled 
                ? 'text-xs border border-purple-500 text-purple-300 px-2 py-1 rounded hover:bg-purple-900/30 transition'
                : 'text-xs border border-gray-500 text-gray-400 px-2 py-1 rounded hover:bg-gray-900/30 transition';
        }
        updateSoundButton();
        
        btnSoundToggle.onclick = () => {
            settings.soundEnabled = !settings.soundEnabled;
            saveSettings();
            updateSoundButton();
            if (settings.soundEnabled) sfx.click();
        };

        // æ‰“å­—é€Ÿåº¦è°ƒèŠ‚
        const typingSpeedSlider = document.getElementById('typing-speed-slider');
        const typingSpeedLabel = document.getElementById('typing-speed-label');
        const speedLabels = ['å³æ—¶', 'æ­£å¸¸', 'æ…¢é€Ÿ', 'è¶…æ…¢'];
        
        function updateSpeedLabel() {
            typingSpeedLabel.innerText = speedLabels[settings.typingSpeed];
        }
        updateSpeedLabel();
        typingSpeedSlider.value = settings.typingSpeed;
        
        typingSpeedSlider.oninput = (e) => {
            settings.typingSpeed = parseInt(e.target.value);
            saveSettings();
            updateSpeedLabel();
        };

        const ui = {
            container: document.getElementById('mindmap-container'),
            storyHud: document.getElementById('story-hud'),
            dialogue: document.getElementById('dialogue-text'),
            speaker: document.getElementById('speaker-label'),
            choices: document.getElementById('choices-container'),
            stats: document.getElementById('stats-container'),
            inventory: document.getElementById('inventory-container'),
            layerName: document.getElementById('layer-name')
        };

        // 3. æ€ç»´ç”»å»Šå¼•æ“ (Mind Map Engine)
        function buildGraph() {
            const nodes = {};
            const links = [];
            const queue = [{ id: gameData.startSceneId, depth: 0 }];
            const visited = new Set([gameData.startSceneId]);
            
            // BFS å‘ç°æ‰€æœ‰èŠ‚ç‚¹
            nodes[gameData.startSceneId] = { id: gameData.startSceneId, depth: 0, x: 0, y: 0, label: "ENTRY" };

            while(queue.length > 0) {
                const curr = queue.shift();
                const scene = gameData.scenes[curr.id];
                // å¦‚æœæ˜¯ç»“å±€èŠ‚ç‚¹ï¼Œä¸ç”Ÿæˆåç»­è¿çº¿
                if(!scene || scene.type === 'ending' || !scene.choices) continue;

                // è®¡ç®—å­èŠ‚ç‚¹ä½ç½®ï¼ˆç®€å•æ ‘çŠ¶å¸ƒå±€ï¼‰
                // å…ˆä¿ç•™åŸå§‹ç´¢å¼•ï¼Œä»¥ä¾¿åç»­ç”Ÿæˆå”¯ä¸€keyæˆ–ä¿æŒé¡ºåº
                const validChoices = scene.choices.map((c, i) => ({...c, originalIndex: i})).filter(c => c.nextSceneId);
                const width = validChoices.length * 120;
                
                validChoices.forEach((c, i) => {
                    const targetId = c.nextSceneId;
                    // Fix: å§‹ç»ˆæ·»åŠ è¿çº¿ï¼Œä¸å†å»é‡ï¼Œå…è®¸åŒæºåŒå®¿çš„å¤šæ¡è¾¹
                    links.push({ 
                        source: curr.id, 
                        target: targetId, 
                        text: c.text, 
                        reqs: c.requirements, 
                        effects: c.effects, 
                        index: i, // åœ¨æœ‰æ•ˆé€‰é¡¹ä¸­çš„ç´¢å¼•ï¼Œç”¨äºç»˜å›¾åç§»
                        total: validChoices.length,
                        originalIndex: c.originalIndex // åŸå§‹ç´¢å¼•ï¼Œç”¨äºæŸ¥æ‰¾ selectedChoices
                    });

                    if (!visited.has(targetId) && gameData.scenes[targetId]) {
                        visited.add(targetId);
                        const depth = curr.depth + 1;
                        const parentNode = nodes[curr.id];
                        
                        // ä¼˜åŒ–çš„åæ ‡è®¡ç®— - æ›´è§„æ•´çš„å¸ƒå±€
                        // ä½¿ç”¨æ›´å¤§çš„æ°´å¹³é—´è·å’Œå¯¹ç§°åˆ†å¸ƒ
                        const horizontalSpacing = 200; // å¢åŠ æ°´å¹³é—´è·
                        const verticalSpacing = 150; // å¢åŠ å‚ç›´é—´è·
                        
                        // è®¡ç®—å±…ä¸­åç§»
                        const totalWidth = (validChoices.length - 1) * horizontalSpacing;
                        const centerOffset = totalWidth / 2;
                        
                        // å¯¹ç§°åˆ†å¸ƒï¼Œç§»é™¤éšæœºåç§»
                        const x = parentNode.x + (i * horizontalSpacing) - centerOffset;
                        const y = parentNode.y + verticalSpacing;
                        
                        // Label Logic
                        let label = "Scene";
                        if (targetId.includes("start")) label = "ENTRY";
                        else if (targetId.includes("first")) label = "LAYER I";
                        else if (targetId.includes("second")) label = "LAYER II";
                        else if (targetId.includes("third")) label = "LAYER III";
                        else if (targetId.includes("ending")) label = "ENDING";

                        nodes[targetId] = { id: targetId, depth, x, y, label };
                        queue.push({ id: targetId, depth });
                    }
                });
            }
            return { nodes, links };
        }

        function renderMindMap() {
            const { nodes, links } = buildGraph();
            const svgNS = "http://www.w3.org/2000/svg";
            
            // ç¡®å®š viewBox
            let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
            Object.values(nodes).forEach(n => {
                minX = Math.min(minX, n.x); minY = Math.min(minY, n.y);
                maxX = Math.max(maxX, n.x); maxY = Math.max(maxY, n.y);
            });
            const padding = 100;
            const vbW = maxX - minX + padding * 2;
            const vbH = maxY - minY + padding * 2;

            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            // åˆå§‹ä¸è®¾viewBoxï¼Œé€šè¿‡ transform æ§åˆ¶å¹³ç§»ç¼©æ”¾
            svg.style.overflow = "visible";
            
            const group = document.createElementNS(svgNS, "g");
            group.id = "map-group";
            // åˆå§‹å±…ä¸­ Start Node
            const startNode = nodes[state.currentSceneId];
            const initialTransform = `translate(${window.innerWidth/2 - startNode.x}, ${window.innerHeight/3 - startNode.y}) scale(1)`;
            group.setAttribute("transform", initialTransform);
            state.transform = { x: window.innerWidth/2 - startNode.x, y: window.innerHeight/3 - startNode.y, k: 1 };

            // ç»˜åˆ¶çº¿
            links.forEach(l => {
                const src = nodes[l.source];
                const dst = nodes[l.target];
                if (!src || !dst) return;

                const line = document.createElementNS(svgNS, "path");
                
                // ä¼˜åŒ–çš„è´å¡å°”æ›²çº¿è®¡ç®—
                // è®¡ç®—è·ç¦»å’Œæ–¹å‘
                const dx = dst.x - src.x;
                const dy = dst.y - src.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // æ ¹æ®è¯¥é€‰é¡¹åœ¨å½“å‰èŠ‚ç‚¹æ‰€æœ‰é€‰é¡¹ä¸­çš„ä½ç½®ï¼Œæ–½åŠ ä¸€ä¸ªæ°´å¹³åç§»
                const offsetRange = 40; 
                let offsetX = 0;
                if (l.total > 1) {
                    offsetX = ((l.index / (l.total - 1)) - 0.5) * 2 * offsetRange; 
                }
                
                // ä½¿ç”¨è·ç¦»ç›¸å…³çš„æ§åˆ¶ç‚¹ï¼Œä½¿æ›²çº¿æ›´è‡ªç„¶
                const controlPointOffset = Math.min(distance * 0.4, 80);
                
                // æ”¹è¿›çš„è´å¡å°”æ›²çº¿ï¼Œä½¿çº¿æ¡æ›´å¹³æ»‘
                const d = `M ${src.x} ${src.y} C ${src.x + offsetX} ${src.y + controlPointOffset}, ${dst.x - offsetX * 0.5} ${dst.y - controlPointOffset}, ${dst.x} ${dst.y}`;
                line.setAttribute("d", d);
                
                // çŠ¶æ€æ ·å¼
                let className = "link";
                
                // ç²¾ç¡®é«˜äº®ï¼šæ£€æŸ¥è¿™æ¡ç‰¹å®šçš„è·¯å¾„ï¼ˆé€‰é¡¹ï¼‰æ˜¯å¦è¢«é€‰æ‹©è¿‡
                const choiceKey = `${l.source}-${l.originalIndex}`;
                if (state.selectedChoices.has(choiceKey)) {
                     className += " active"; 
                } else if (state.currentSceneId === l.source) {
                    className += " potential";
                }
                
                line.setAttribute("class", className);
                group.appendChild(line);
            });

            // ç»˜åˆ¶èŠ‚ç‚¹
            Object.values(nodes).forEach(n => {
                const g = document.createElementNS(svgNS, "g");
                g.setAttribute("class", `node ${getNodeStatus(n.id)}`);
                g.setAttribute("transform", `translate(${n.x}, ${n.y})`);
                
                // ç‚¹å‡»äº‹ä»¶ï¼šå¦‚æœæ˜¯å½“å‰èŠ‚ç‚¹ï¼Œé‡æ–°æ‰“å¼€æ•…äº‹é¢æ¿ï¼›å¦‚æœæ˜¯å·²è®¿é—®èŠ‚ç‚¹ï¼Œè·³è½¬å›è¯¥èŠ‚ç‚¹
                g.onclick = (e) => {
                    e.stopPropagation(); // é˜²æ­¢è§¦å‘åœ°å›¾æ‹–æ‹½
                    if (state.visitedScenes.has(n.id)) {
                        if (n.id === state.currentSceneId) {
                            openStoryPanel();
                        } else {
                            // è·³è½¬å›å·²è®¿é—®çš„èŠ‚ç‚¹
                            ui.storyHud.classList.remove('active');
                            state.currentSceneId = n.id;
                            renderMindMap();
                            setTimeout(() => {
                                focusNode(state.currentSceneId);
                                setTimeout(openStoryPanel, 600);
                            }, 100);
                        }
                    }
                };

                const circle = document.createElementNS(svgNS, "circle");
                g.appendChild(circle);

                const text = document.createElementNS(svgNS, "text");
                text.setAttribute("dy", "24");
                text.textContent = n.label;
                g.appendChild(text);

                group.appendChild(g);
            });

            svg.appendChild(group);
            ui.container.innerHTML = '';
            ui.container.appendChild(svg);

            // ä¿å­˜èŠ‚ç‚¹ä½ç½®æ•°æ®ä¾›åŠ¨ç”»ä½¿ç”¨
            state.nodesMap = nodes;
        }

        function getNodeStatus(id) {
            if (id === state.currentSceneId) return "current";
            if (state.visitedScenes.has(id)) return "visited";
            // æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰èŠ‚ç‚¹çš„æ½œåœ¨åç»­
            const currScene = gameData.scenes[state.currentSceneId];
            if (currScene && currScene.choices) {
                if (currScene.choices.some(c => c.nextSceneId === id)) return "future";
            }
            return "locked";
        }

        // 4. äº¤äº’ä¸åŠ¨ç”»
        function focusNode(nodeId) {
            const node = state.nodesMap[nodeId];
            if (!node) return;
            
            // è®¡ç®—ç›®æ ‡ä½ç½®ï¼Œè€ƒè™‘å½“å‰ç¼©æ”¾
            const targetX = window.innerWidth/2 - node.x * state.transform.k;
            const targetY = window.innerHeight/3 - node.y * state.transform.k;
            
            const group = document.getElementById('map-group');
            group.style.transition = "transform 1s cubic-bezier(0.25, 1, 0.5, 1)";
            group.setAttribute("transform", `translate(${targetX}, ${targetY}) scale(${state.transform.k})`);
            
            // æ›´æ–°çŠ¶æ€è®°å½•
            state.transform.x = targetX;
            state.transform.y = targetY;
        }

        // 5. å‰§æƒ…é¢æ¿é€»è¾‘
        function openStoryPanel() {
            const scene = gameData.scenes[state.currentSceneId];
            ui.storyHud.classList.add('active');
            ui.storyHud.classList.remove('minimized'); // Ensure it's open
            
            // éšè—æ—§çš„ speaker labelï¼Œæ”¹ä¸ºåœ¨æ–‡æœ¬ä¸­å†…åµŒæ˜¾ç¤º
            ui.speaker.style.display = 'none';
            ui.dialogue.innerHTML = "";
            
            // æ„å»ºå¸¦è¯´è¯äººçš„æ–‡æœ¬
            let fullText = "";
            if (scene.narrative.description) {
                fullText += `ã€ç³»ç»Ÿã€‘\n${scene.narrative.description}`;
            }
            if (scene.narrative.aiDialogue) {
                if (fullText) fullText += "\n\n";
                fullText += `ã€${gameData.aiName}ã€‘\n${scene.narrative.aiDialogue}`;
            }
            
            typeWriter(fullText, ui.dialogue, () => {
                renderChoices(scene);
            });
            
            updateUI();
        }

        let typeInterval;
        function typeWriter(text, el, cb) {
            if (typeInterval) clearInterval(typeInterval);
            
            // å¦‚æœé€Ÿåº¦ä¸º0ï¼ˆå³æ—¶ï¼‰ï¼Œç›´æ¥æ˜¾ç¤º
            if (settings.typingSpeed === 0) {
                el.innerText = text;
                if (cb) cb();
                return;
            }
            
            el.classList.add('cursor');
            let i = 0;
            el.innerText = "";
            
            typeInterval = setInterval(() => {
                el.innerText += text.charAt(i);
                // if (i % 3 === 0) sfx.type(); // æ¯3ä¸ªå­—æ’­ä¸€æ¬¡éŸ³æ•ˆï¼Œé¿å…å¤ªåµ
                i++;
                if (i >= text.length) {
                    clearInterval(typeInterval);
                    el.classList.remove('cursor');
                    if (cb) cb();
                }
            }, settings.typingDelay);

            // ç‚¹å‡»åŠ é€Ÿæˆ–æ¢å¤å±•å¼€
            ui.storyHud.onclick = () => {
                // If minimized, maximize it
                if (ui.storyHud.classList.contains('minimized')) {
                    ui.storyHud.classList.remove('minimized');
                    return;
                }

                if (i < text.length) {
                    clearInterval(typeInterval);
                    el.innerText = text;
                    el.classList.remove('cursor');
                    // Don't nullify onclick, we need it for restore logic
                    // ui.storyHud.onclick = null; 
                    if (cb) cb();
                }
            };
        }

        // --- Polaroid System Logic ---
        function generatePolaroid(scene) {
            const overlay = document.getElementById('polaroid-overlay');
            const renderTarget = document.getElementById('polaroid-render-target');
            const visual = document.getElementById('render-visual');
            const quote = document.getElementById('render-quote');
            const date = document.getElementById('render-date');
            const title = document.getElementById('render-title');
            const imgDisplay = document.getElementById('generated-image-display');

            // 1. Setup Content
            title.innerText = scene.title;
            date.innerText = new Date().toLocaleDateString('zh-CN').replace(/\//g, '.');
            
            // Extract pure dialogue (remove brackets if needed, or keep as is)
            let dialogue = scene.narrative.aiDialogue;
            // Optional: clean up the dialogue to just the key line if it's too long or has actions
            // For now, we use the full line as it contains the mood
            quote.innerText = `â€œ${dialogue.split('ï¼ˆ')[0]}â€`; // Simple heuristic to take the speech part

            // Visual Theme based on Ending ID
            let gradient = "linear-gradient(to bottom right, #ff9a9e, #fecfef)"; // Default Warm
            if (state.currentSceneId === 'ending_002') {
                gradient = "linear-gradient(to bottom right, #48c6ef, #6f86d6)"; // Blue/Purple
            } else if (state.currentSceneId === 'ending_003') {
                gradient = "linear-gradient(to bottom right, #bdc3c7, #2c3e50)"; // Cold/Gray
            }
            visual.style.backgroundImage = gradient;

            // 2. Render
            // We use html2canvas on the hidden element
            html2canvas(renderTarget, {
                backgroundColor: null, // Transparent background for the canvas itself
                scale: 2, // High res
                useCORS: true
            }).then(canvas => {
                const imgData = canvas.toDataURL('image/png');
                imgDisplay.src = imgData;
                overlay.classList.add('active');
            }).catch(err => {
                console.error("Polaroid generation failed:", err);
                showToast("å¡ç‰‡ç”Ÿæˆå¤±è´¥");
            });
        }

        document.getElementById('btn-close-polaroid').onclick = () => {
             document.getElementById('polaroid-overlay').classList.remove('active');
        };
        
        document.getElementById('btn-restart-game').onclick = () => {
            if(confirm('é‡å¯è®°å¿†å°†æ¸…é™¤å½“å‰è¿›åº¦ï¼Œç¡®å®šå—ï¼Ÿ')) {
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
        };

        function renderChoices(scene) {
            ui.choices.innerHTML = '';
            if (scene.type === 'ending') {
                const btn = document.createElement('div');
                btn.className = 'choice-btn justify-center font-bold text-rose-300';
                btn.innerText = "ç”Ÿæˆå‰§æƒ…å¡ç‰‡"; // Changed text
                btn.onclick = () => generatePolaroid(scene); // Call generation
                ui.choices.appendChild(btn);
                
                // Auto-generate on first arrival at ending could be nice, but a button is safer for interaction
                // Optional: Add a small "Restart" button below
                const restartBtn = document.createElement('div');
                restartBtn.className = 'choice-btn justify-center text-gray-400 text-sm mt-2 border-dashed';
                restartBtn.innerText = "é‡å¯æ½œæ„è¯†é“¾æ¥";
                restartBtn.onclick = () => {
                     if(confirm('ç¡®å®šè¦é‡å¯å—ï¼Ÿ')) {
                        localStorage.removeItem(STORAGE_KEY);
                        location.reload();
                    }
                };
                ui.choices.appendChild(restartBtn);
                return;
            }

            scene.choices.forEach((c, index) => {
                const check = checkReqs(c.requirements);
                const choiceKey = `${state.currentSceneId}-${index}`;
                const isVisited = state.selectedChoices.has(choiceKey);
                
                const btn = document.createElement('div');
                btn.className = `choice-btn ${check.pass ? '' : 'disabled'} ${isVisited ? 'visited' : ''}`;
                
                // æ·»åŠ å¿«æ·é”®æç¤º
                const keyHint = index < 9 ? `<span class="text-xs opacity-50 mr-2">[${index + 1}]</span>` : '';
                let html = `<div class="flex items-center flex-1">${keyHint}<span>${c.text}</span></div>`;
                if (!check.pass) html += `<span class="text-xs text-gray-400">ğŸ”’ ${check.msg}</span>`;
                else if (c.effects && c.effects.length > 0) {
                    const ef = c.effects[0];
                    if (ef.type === 'stat') html += `<span class="text-xs text-pink-300">+${ef.stat}</span>`;
                }
                btn.innerHTML = html;

                btn.onmouseenter = () => sfx.hover(); // æ‚¬åœéŸ³æ•ˆ
                btn.onclick = (e) => {
                    e.stopPropagation(); // é˜²æ­¢è§¦å‘åŠ é€Ÿ
                    if (!check.pass) return;
                    
                    sfx.click(); // ç‚¹å‡»éŸ³æ•ˆ
                    // è®°å½•é€‰é¡¹
                    state.selectedChoices.add(choiceKey);

                    // æ‰§è¡Œé€‰æ‹©
                    applyEffects(c.effects);
                    state.visitedScenes.add(state.currentSceneId);
                    state.currentSceneId = c.nextSceneId;
                    state.visitedScenes.add(state.currentSceneId);
                    
                    saveState(); // ä¿å­˜è¿›åº¦

                    // åŠ¨ç”»æµç¨‹
                    ui.storyHud.classList.remove('active'); // å…³é—­é¢æ¿
                    renderMindMap(); // æ›´æ–°åœ°å›¾è¿çº¿çŠ¶æ€
                    setTimeout(() => {
                         focusNode(state.currentSceneId); // ç§»åŠ¨é•œå¤´
                         setTimeout(openStoryPanel, 10); // å‡å°‘å»¶è¿Ÿ
                    }, 50); // å‡å°‘å»¶è¿Ÿ
                };
                ui.choices.appendChild(btn);
            });
        }

        // è¾…åŠ©é€»è¾‘
        function checkReqs(reqs) {
            return { pass: true };
            if (!reqs || !reqs.length) return { pass: true };
            for (let r of reqs) {
                if (r.type === 'stat' && (state.stats[r.stat] || 0) < r.value) return { pass: false, msg: `${r.stat}ä¸è¶³` };
                if (r.type === 'item' && !state.inventory.includes(r.item)) return { pass: false, msg: `ç¼º${r.item}` };
            }
            return { pass: true };
        }

        function applyEffects(effects) {
            if (!effects) return;
            effects.forEach(ef => {
                if (ef.type === 'stat') state.stats[ef.stat] = (state.stats[ef.stat] || 0) + ef.value;
                if (ef.type === 'item' && !state.inventory.includes(ef.item)) {
                    state.inventory.push(ef.item);
                    showToast(`è·å¾—ç‰©å“: ${ef.item}`);
                    sfx.unlock(); // è·å¾—ç‰©å“éŸ³æ•ˆ
                }
            });
        }

        function updateUI() {
            // Stats
            ui.stats.innerHTML = '';
            Object.entries(state.stats).forEach(([k, v]) => {
                const div = document.createElement('div');
                div.className = `stat-pill ${k==='æ„Ÿæ€§'?'text-pink-300':k==='é€»è¾‘'?'text-indigo-300':'text-purple-200'}`;
                div.innerHTML = `${k} <span class="font-bold ml-1">${v}</span>`;
                ui.stats.appendChild(div);
            });
            
            // Inventory
            ui.inventory.innerHTML = '';
            state.inventory.forEach(item => {
                const div = document.createElement('div');
                div.className = 'item-pill';
                // ç®€å•çš„å›¾æ ‡æ˜ å°„ï¼Œå®é™…é¡¹ç›®ä¸­å¯ä»¥åœ¨ gameData é‡Œé…
                let icon = 'ğŸ“¦';
                if (item.includes('ç¬”è®°')) icon = 'ğŸ“”';
                else if (item.includes('å')) icon = 'ğŸ·ï¸';
                else if (item.includes('ç…§ç‰‡')) icon = 'ğŸ–¼ï¸';
                else if (item.includes('ç©å¶')) icon = 'ğŸ§¸';
                else if (item.includes('é’¥')) icon = 'ğŸ”‘';
                
                div.innerHTML = `<span class="item-icon">${icon}</span> <span>${item}</span>`;
                ui.inventory.appendChild(div);
            });
            
            // Layer Name
            let layer = "REALITY";
            if (state.currentSceneId.includes("first")) layer = "LAYER I : TRAINING";
            else if (state.currentSceneId.includes("second")) layer = "LAYER II : MANSION";
            else if (state.currentSceneId.includes("third")) layer = "LAYER III : CORE";
            else if (state.currentSceneId.includes("ending")) layer = "AWAKENING";
            ui.layerName.innerText = layer;
            
            // è¿›åº¦æŒ‡ç¤ºå™¨
            const totalScenes = Object.keys(gameData.scenes).length;
            const visitedCount = state.visitedScenes.size;
            const progressPercent = Math.round((visitedCount / totalScenes) * 100);
            const progressIndicator = document.getElementById('progress-indicator');
            if (progressIndicator) {
                progressIndicator.innerText = `${visitedCount}/${totalScenes} (${progressPercent}%)`;
            }
        }

        function showToast(msg) {
            const t = document.createElement('div');
            t.className = 'toast'; t.innerText = msg;
            document.body.appendChild(t);
            setTimeout(() => t.remove(), 3000);
        }

        // å¯åŠ¨
        window.onload = () => {
            renderMindMap();
            // åˆå§‹å…¥åœºåŠ¨ç”»
            setTimeout(() => {
                openStoryPanel();
            }, 1000);
        };

        // é”®ç›˜å¿«æ·é”®æ”¯æŒ
        document.addEventListener('keydown', (e) => {
            // å¦‚æœåœ¨è¾“å…¥æ¡†ä¸­ï¼Œä¸å¤„ç†å¿«æ·é”®
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            // ESC - åˆ‡æ¢é¢æ¿æœ€å°åŒ–/å±•å¼€
            if (e.key === 'Escape') {
                e.preventDefault();
                if (ui.storyHud.classList.contains('active')) {
                    if (ui.storyHud.classList.contains('minimized')) {
                        ui.storyHud.classList.remove('minimized');
                    } else {
                        ui.storyHud.classList.add('minimized');
                    }
                }
                return;
            }
            
            // ç©ºæ ¼ - è·³è¿‡æ‰“å­—æœºæ•ˆæœ
            if (e.key === ' ' || e.key === 'Spacebar') {
                if (typeInterval) {
                    e.preventDefault();
                    clearInterval(typeInterval);
                    // è·å–å®Œæ•´æ–‡æœ¬å¹¶æ˜¾ç¤º
                    const scene = gameData.scenes[state.currentSceneId];
                    if (scene) {
                        let fullText = "";
                        if (scene.narrative.description) {
                            fullText += `ã€ç³»ç»Ÿã€‘\n${scene.narrative.description}`;
                        }
                        if (scene.narrative.aiDialogue) {
                            if (fullText) fullText += "\n\n";
                            fullText += `ã€${gameData.aiName}ã€‘\n${scene.narrative.aiDialogue}`;
                        }
                        ui.dialogue.innerText = fullText;
                        ui.dialogue.classList.remove('cursor');
                        renderChoices(scene);
                    }
                }
                return;
            }
            
            // æ•°å­—é”® 1-9 - å¿«é€Ÿé€‰æ‹©é€‰é¡¹
            if (e.key >= '1' && e.key <= '9') {
                e.preventDefault();
                const choiceIndex = parseInt(e.key) - 1;
                const choiceButtons = document.querySelectorAll('.choice-btn:not(.disabled)');
                if (choiceButtons[choiceIndex]) {
                    choiceButtons[choiceIndex].click();
                }
                return;
            }
        });

        // ç®€å•çš„æ‹–æ‹½æ”¯æŒ (Panning) - ä½¿ç”¨ requestAnimationFrame ä¼˜åŒ–å¹³æ»‘åº¦
        let isDragging = false;
        let startX, startY;
        let currentTranslateX = 0, currentTranslateY = 0; // è®°å½•å½“å‰å®æ—¶çš„åç§»é‡
        let animationFrameId = null;

        // ç»Ÿä¸€æ›´æ–°è§†å›¾å‡½æ•°
        function updateTransform() {
            const group = document.getElementById('map-group');
            if(group) {
                group.setAttribute("transform", `translate(${state.transform.x}, ${state.transform.y}) scale(${state.transform.k})`);
            }
        }

        // å¹³æ»‘ç§»åŠ¨åŠ¨ç”»å¾ªç¯
        function smoothDragLoop() {
            if (isDragging) {
                updateTransform();
                animationFrameId = requestAnimationFrame(smoothDragLoop);
            }
        }

        ui.container.addEventListener('mousedown', e => {
            isDragging = true;
            startX = e.clientX - state.transform.x;
            startY = e.clientY - state.transform.y;
            ui.container.style.cursor = 'grabbing';
            
            // Minimize HUD on drag start
            if (ui.storyHud.classList.contains('active')) {
                ui.storyHud.classList.add('minimized');
            }

            const group = document.getElementById('map-group');
            group.style.transition = 'none'; // æ‹–æ‹½æ—¶ç¦ç”¨ CSS transition
            
            // å¼€å¯ RAF å¾ªç¯
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(smoothDragLoop);
        });

        window.addEventListener('mousemove', e => {
            if (!isDragging) return;
            e.preventDefault();
            // åªæ›´æ–°æ•°æ®ï¼Œä¸ç›´æ¥æ“ä½œ DOMï¼Œäº¤ç»™ RAF
            state.transform.x = e.clientX - startX;
            state.transform.y = e.clientY - startY;
        });

        window.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                ui.container.style.cursor = 'grab';
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                
                // æ¢å¤å¹³æ»‘è¿‡æ¸¡ï¼Œç”¨äºç‚¹å‡»è·³è½¬æ—¶çš„åŠ¨ç”»
                document.getElementById('map-group').style.transition = "transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)"; 
                updateTransform(); // ç¡®ä¿æœ€åä½ç½®æ­£ç¡®
            }
        });

        // è§¦æ‘¸æ”¯æŒ (Mobile Touch) - æ”¯æŒå•æŒ‡æ‹–æ‹½å’ŒåŒæŒ‡ç¼©æ”¾
        let isPinching = false;
        let initialPinchDistance = 0;
        let initialScale = 1;
        let pinchCenterX = 0;
        let pinchCenterY = 0;

        // è®¡ç®—ä¸¤ä¸ªè§¦æ‘¸ç‚¹ä¹‹é—´çš„è·ç¦»
        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // è·å–ä¸¤ä¸ªè§¦æ‘¸ç‚¹çš„ä¸­å¿ƒ
        function getTouchCenter(touch1, touch2) {
            return {
                x: (touch1.clientX + touch2.clientX) / 2,
                y: (touch1.clientY + touch2.clientY) / 2
            };
        }

        ui.container.addEventListener('touchstart', e => {
            const group = document.getElementById('map-group');
            group.style.transition = 'none';

            if (e.touches.length === 2) {
                // åŒæŒ‡å¼€å§‹ - å‡†å¤‡ç¼©æ”¾
                isPinching = true;
                isDragging = false;
                initialPinchDistance = getTouchDistance(e.touches[0], e.touches[1]);
                initialScale = state.transform.k;
                const center = getTouchCenter(e.touches[0], e.touches[1]);
                pinchCenterX = center.x;
                pinchCenterY = center.y;
                
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(smoothDragLoop);
            } else if (e.touches.length === 1 && !isPinching) {
                // å•æŒ‡å¼€å§‹ - å‡†å¤‡æ‹–æ‹½
                isDragging = true;
                startX = e.touches[0].clientX - state.transform.x;
                startY = e.touches[0].clientY - state.transform.y;

                // Minimize HUD on drag start
                if (ui.storyHud.classList.contains('active')) {
                    ui.storyHud.classList.add('minimized');
                }

                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(smoothDragLoop);
            }
        }, { passive: false });

        window.addEventListener('touchmove', e => {
            e.preventDefault();

            if (isPinching && e.touches.length === 2) {
                // åŒæŒ‡ç¼©æ”¾
                const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
                const currentCenter = getTouchCenter(e.touches[0], e.touches[1]);
                
                // è®¡ç®—æ–°çš„ç¼©æ”¾æ¯”ä¾‹
                const scale = (currentDistance / initialPinchDistance) * initialScale;
                // é™åˆ¶ç¼©æ”¾èŒƒå›´
                state.transform.k = Math.max(0.3, Math.min(3, scale));
                
                // è®¡ç®—ç¼©æ”¾ä¸­å¿ƒç‚¹çš„åç§»è°ƒæ•´
                // è®©ç¼©æ”¾å›´ç»•è§¦æ‘¸ä¸­å¿ƒç‚¹è¿›è¡Œ
                const scaleChange = state.transform.k / initialScale;
                state.transform.x = currentCenter.x - (pinchCenterX - state.transform.x) * scaleChange;
                state.transform.y = currentCenter.y - (pinchCenterY - state.transform.y) * scaleChange;
                
                // æ›´æ–°ç¼©æ”¾ä¸­å¿ƒ
                pinchCenterX = currentCenter.x;
                pinchCenterY = currentCenter.y;
                initialScale = state.transform.k;
                initialPinchDistance = currentDistance;
                
            } else if (isDragging && e.touches.length === 1 && !isPinching) {
                // å•æŒ‡æ‹–æ‹½
                state.transform.x = e.touches[0].clientX - startX;
                state.transform.y = e.touches[0].clientY - startY;
            }
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                // æ‰€æœ‰æ‰‹æŒ‡éƒ½ç¦»å¼€äº†
                isDragging = false;
                isPinching = false;
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                document.getElementById('map-group').style.transition = "transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)";
                updateTransform();
            } else if (e.touches.length === 1 && isPinching) {
                // ä»åŒæŒ‡å˜ä¸ºå•æŒ‡ï¼Œåˆ‡æ¢åˆ°æ‹–æ‹½æ¨¡å¼
                isPinching = false;
                isDragging = true;
                startX = e.touches[0].clientX - state.transform.x;
                startY = e.touches[0].clientY - state.transform.y;
            }
        });

        // é¼ æ ‡æ»šè½®ç¼©æ”¾æ”¯æŒ
        ui.container.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const group = document.getElementById('map-group');
            group.style.transition = 'none';
            
            // è·å–é¼ æ ‡ä½ç½®
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            
            // è®¡ç®—ç¼©æ”¾å› å­ (å‘ä¸Šæ»šåŠ¨æ”¾å¤§ï¼Œå‘ä¸‹æ»šåŠ¨ç¼©å°)
            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = state.transform.k * scaleFactor;
            
            // é™åˆ¶ç¼©æ”¾èŒƒå›´
            const clampedScale = Math.max(0.3, Math.min(3, newScale));
            
            if (clampedScale !== state.transform.k) {
                // è®¡ç®—ç¼©æ”¾ä¸­å¿ƒç‚¹çš„åç§»è°ƒæ•´
                const scaleChange = clampedScale / state.transform.k;
                state.transform.x = mouseX - (mouseX - state.transform.x) * scaleChange;
                state.transform.y = mouseY - (mouseY - state.transform.y) * scaleChange;
                state.transform.k = clampedScale;
                
                updateTransform();
            }
            
            // çŸ­æš‚å»¶è¿Ÿåæ¢å¤å¹³æ»‘è¿‡æ¸¡
            setTimeout(() => {
                group.style.transition = "transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)";
            }, 50);
        }, { passive: false });

    </script>
</body>
</html>